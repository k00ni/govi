#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * Read ontology information from:
 *
 * https://archivo.dbpedia.org/list
 *
 * TODO:
 * - take latest access from ontology list of the website
 */

use App\IndexEntry;
use quickRdf\DataFactory;
use quickRdfIo\Util;
use Symfony\Component\Cache\Adapter\FilesystemAdapter;

use function App\addFurtherMetadata;
use function App\cleanTitle;
use function App\isEmpty;
use function App\loadQuadsIntoEasyRdfGraph;
use function App\sendCachedRequest;
use function App\storeTemporaryIndexIntoSQLiteFile;

require 'bootstrap.php';

// time limit for script
\set_time_limit(3600);

echo 'load ontologies list and build temporary index';

/*
 * 1. ask DBpedia archivo to the complete list of ontologies
 */
$url = 'https://archivo.dbpedia.org/list';
$html = file_get_contents($url);

/*
 * 2. build basic index for this provider
 */
$numberOfOntologyEntries = preg_match_all('/<tr>(.*?)<\/tr>/sim', $html, $ontologyEntries);

echo PHP_EOL.'found '.$numberOfOntologyEntries.' entries, processing ...';

/*
 * 3. go through each ontology and build index
 */
if (0 < $numberOfOntologyEntries) {
    $dataFactory = new DataFactory();

    // this structure contains a temporary index which only holds data about received ontologies
    $temporaryIndex = [];

    // go through received ontologies
    foreach ($ontologyEntries[1] as $ontologyEntryHtml) {
        if (str_contains($ontologyEntryHtml, '<th ')) {
            continue;
        }

        // new entry in temporary index
        $newEntry = new IndexEntry('DBpedia Archivo', $url);

        // info page + title/name of ontology
        preg_match('/<td>\s*\n*<a href="(\/info\?o=.*?)">(.*?)</sim', $ontologyEntryHtml, $data);
        if (isset($data[1]) && false === isEmpty($data[1])) {
            $newEntry->setSourcePageUrl('https://archivo.dbpedia.org/'.$data[1]);
        }
        if (isset($data[1]) && false === isEmpty($data[2])) {
            $newEntry->setOntologyTitle(cleanTitle($data[2]));
        } else {
            echo PHP_EOL.'no ontology title, so ignore entry with HTML: '.$ontologyEntryHtml;

            // no title means, no valid meta data, therefore stop
            continue;
        }

        // URI of ontology
        preg_match('/<td>\s*<a href="\/info\?o=(.*?)"/sim', $ontologyEntryHtml, $uri);
        if (isset($uri[1]) && false === isEmpty($uri[1])) {
            $newEntry->setontologyIri($uri[1]);

            if (isset($temporaryIndex[$newEntry->getOntologyIri()])) {
                echo PHP_EOL.'- DUPLICATE: entry with ontology URI '.$uri[1].' already set!';
            }
        } else {
            echo PHP_EOL.'no ontology URI, so ignore entry with HTML: '.$ontologyEntryHtml;

            // no URI means, no valid meta data, therefore stop
            continue;
        }

        // latest update date
        preg_match('/nt<\/a>.*?>([0-9]{4})\.([0-9]{2})\.([0-9]{2})/sim', $ontologyEntryHtml, $latest);
        if (isset($latest[1]) && false === isEmpty($latest[1])) {
            $latestAccess = $latest[1].'-'.$latest[2].'-'.$latest[3];
            $newEntry->setLatestAccess($latestAccess);
        } else {
            $message = 'Can not read latest timestamp field for '.$newEntry->getOntologyIri().' // RAW HTML : '.$ontologyEntryHtml;
            throw new Exception($message);
        }

        echo '.';

        /*
         * latest OWL,TTL,... file
         */
        $iriUrlEncoded = urlencode($newEntry->getOntologyIri());
        $newEntry->setLatestNtFile('http://archivo.dbpedia.org/download?o='.$iriUrlEncoded.'&f=nt');
        $newEntry->setLatestRdfXmlFile('http://archivo.dbpedia.org/download?o='.$iriUrlEncoded.'&f=owl');
        $newEntry->setLatestTtlFile('http://archivo.dbpedia.org/download?o='.$iriUrlEncoded.'&f=ttl');

        // download TTL file to extract further meta data
        try {
            $graph = loadQuadsIntoEasyRdfGraph($newEntry->getLatestNtFile(), 'ntriples');
        } catch (Exception $e) {
            if (str_contains($e->getMessage(), 'CURLE_OPERATION_TIMEOUTED')) {
                echo PHP_EOL.'Curl timeout for '.$newEntry->getLatestNtFile();
                continue;
            } else {
                throw $e;
            }
        }

        addFurtherMetadata($newEntry, $graph);
        $graph = null;

        // store (use URI as key to avoid doublings)
        $temporaryIndex[$newEntry->getOntologyIri()] = $newEntry;

        if (count($temporaryIndex) % 300 == 0) {
            storeTemporaryIndexIntoSQLiteFile($temporaryIndex);
            $temporaryIndex = [];
            gc_collect_cycles();
        }
    }
} else {
    // nothing found or error
    throw new Exception('No ontology entries found at '.$url);
}

echo PHP_EOL.'store temporary index in SQLite file';

/*
 * 4. Store temporary index in SQLite file.
 */
storeTemporaryIndexIntoSQLiteFile($temporaryIndex);

echo PHP_EOL.'done, '.count($temporaryIndex).' entries processed (TODO move to stats)';

echo PHP_EOL;
echo PHP_EOL;
